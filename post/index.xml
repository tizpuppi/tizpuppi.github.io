<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on tizpuppi</title>
    <link>https://tizpuppi.github.io/post/</link>
    <description>Recent content in Posts on tizpuppi</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 28 Oct 2016 09:00:00 +0200</lastBuildDate>
    <atom:link href="https://tizpuppi.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Tour Of Elm - Part Two</title>
      <link>https://tizpuppi.github.io/blog/tour_of_elm-part_two/</link>
      <pubDate>Fri, 28 Oct 2016 09:00:00 +0200</pubDate>
      
      <guid>https://tizpuppi.github.io/blog/tour_of_elm-part_two/</guid>
      <description>

&lt;h1 id=&#34;angular-2-tutorial-in-elm-part-2&#34;&gt;Angular 2 Tutorial in Elm - Part 2&lt;/h1&gt;

&lt;h3 id=&#34;let-s-scale-multiple-heroes&#34;&gt;Let&amp;rsquo;s scale: multiple heroes&lt;/h3&gt;

&lt;p&gt;We are ready to continue our journey of the angular 2 tutorial in Elm. We have touched a bit the Elm architecture in &lt;a href=&#34;https://tizpuppi.github.io/blog/tour_of_elm-part_one/&#34;&gt;previous post&lt;/a&gt; and now we are ready to build on it. We left the application at the point where there was one hero displayed on the page and we were able to nicely change its name.&lt;/p&gt;

&lt;p&gt;Now it&amp;rsquo;s time to grow and we want to scale this feature on multiple heroes, showing a list of heroes among which we can choose, and changing its name once selected. Here you can see a screenshot of the desired behaviour:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tizpuppi.github.io/images/HeroList.gif&#34; alt=&#34;Hero List Screenshot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As usual all code is available in the &lt;a href=&#34;https://github.com/tizpuppi/TourOfElm&#34;&gt;github&lt;/a&gt; repository: for this post you can refer to branch 02-HeroList.&lt;/p&gt;

&lt;p&gt;We will build on top of the code we wrote for previous post.&lt;/p&gt;

&lt;h6 id=&#34;model&#34;&gt;model&lt;/h6&gt;

&lt;p&gt;Let&amp;rsquo;s start to refactor the model:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elm&#34;&gt;-- MODEL


type alias Hero =
    { id : Int, name : String }


heroes : List Hero
heroes =
    [ Hero 11 &amp;quot;Mr. Nice&amp;quot;
    , Hero 12 &amp;quot;Narco&amp;quot;
    , Hero 13 &amp;quot;Bombasto&amp;quot;
    , Hero 14 &amp;quot;Celeritas&amp;quot;
    , Hero 15 &amp;quot;Magneta&amp;quot;
    , Hero 16 &amp;quot;RubberMan&amp;quot;
    , Hero 17 &amp;quot;Dynama&amp;quot;
    , Hero 18 &amp;quot;Dr IQ&amp;quot;
    , Hero 19 &amp;quot;Magma&amp;quot;
    , Hero 20 &amp;quot;Tornado&amp;quot;
    ]


type alias Model =
    { selectedHeroId : Maybe Int, heroes : List Hero }


initialModel : Model
initialModel =
    { selectedHeroId = Nothing, heroes = heroes }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hero type alias doesn&amp;rsquo;t change from previous version, but now the Model type alias is defined as a record containing the id of the selected hero (if any) and a list of heroes (defined separately for sake of clarity).&lt;/p&gt;

&lt;p&gt;In Elm, like in other functional languages List is a key data structure. Lists are iterable containers containing data of same type and are often used to transform data or perform computations over them: we&amp;rsquo;ll see later an example of this in action when transforming list of Heroes into list of Html objects.&lt;/p&gt;

&lt;p&gt;The second interesting Elm feature is that there is no null value. This is quite a revolution if compared to javascript, and I tend to believe that this is one of Elm&amp;rsquo;s greatest feature.&lt;/p&gt;

&lt;p&gt;Not having any null reference has some implications, like that if we want to describe the lack of value we have to explicitly describe it through a type. In Elm this is done using the &lt;strong&gt;Maybe&lt;/strong&gt; type.&lt;/p&gt;

&lt;p&gt;Maybe is a container similar to a list. The only difference is that it can contain 0 or 1 value, while a list can contain 0 or more values of the same type. Being a container, Maybe is a parametric type: we can have Maybe Int, or Maybe String or Maybe WhatEverYouWant. Normally the parameter is denoted with lower case letter, like &lt;strong&gt;Maybe a&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Maybe a has two constructors: &lt;strong&gt;Nothing&lt;/strong&gt; that indicates the lack of value, and &lt;strong&gt;Just a&lt;/strong&gt;: for example &lt;em&gt;Just 5&lt;/em&gt; has type &lt;em&gt;Maybe Int&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;As showed in the code above, we use Maybe Int to describe the id of selected item (or lack of selection).&lt;/p&gt;

&lt;h6 id=&#34;view&#34;&gt;view&lt;/h6&gt;

&lt;p&gt;Let&amp;rsquo;s now have a look at the view:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elm&#34;&gt;-- VIEW


showDetail : Model -&amp;gt; Html Msg
showDetail model =
    case model.selectedHeroId of
        Nothing -&amp;gt;
            text &amp;quot;&amp;quot;

        Just i -&amp;gt;
            div []
                [ h2 []
                    [ text ((getHero i model.heroes).name ++ &amp;quot; details!&amp;quot;)
                    ]
                , div []
                    [ label [] [ text (&amp;quot;id: &amp;quot; ++ toString i) ]
                    ]
                , div []
                    [ label [] [ text &amp;quot;name: &amp;quot; ]
                    , input
                        [ value (getHero i model.heroes).name
                        , placeholder &amp;quot;name&amp;quot;
                        , onInput Change
                        ]
                        []
                    ]
                ]


showList : Model -&amp;gt; List (Html Msg)
showList model =
    List.map
        (\e -&amp;gt;
            li
                [ onClick (Select e)
                , if isHeroSelected model.selectedHeroId e then
                    (class &amp;quot;selected&amp;quot;)
                  else
                    class &amp;quot;&amp;quot;
                ]
                [ span [ class &amp;quot;badge&amp;quot; ] [ text (toString e.id) ], text e.name ]
        )
        model.heroes


view : Model -&amp;gt; Html Msg
view model =
    body []
        [ h1 [] [ text config.title ]
        , h2 [] [ text &amp;quot;My Heroes&amp;quot; ]
        , ul [ class &amp;quot;items&amp;quot; ] (showList model)
        , showDetail model
        ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we start reading from the last function (view), it&amp;rsquo;s pretty clear what this function does: it displays the title in a header, a sub-header, a list and some details.&lt;/p&gt;

&lt;p&gt;Here we can learn another important lesson well stated in the Elm Architecture Guide:&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;We do not think in terms of reusable components. Instead, we focus on reusable functions. It is a functional language after all!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is a pattern we will see through the whole tutorial: we will split our application by isolating small functions in modules. We prefer function composition over components assembling, especially when we are dealing conceptually with one subject (aka one model) like a list of heroes. Structuring an applications by means of reusable components is still possible to do in Elm, but this approach is suggested when each component is a really standalone piece with its own life (aka state or model in Elm terminology).&lt;/p&gt;

&lt;p&gt;As anticipated earlier, in this snippet of code we can also see how List is used to transform data from Model to Html. List.map is an Elm core utility function that takes a function and a list and returns a new list with the function applied to every element of the original list. Here the functions is an anonymous function: syntax for anonymous functions is  &lt;code&gt;(\e -&amp;gt; ... )&lt;/code&gt; where &lt;code&gt;e&lt;/code&gt; is the input parameter and in this case represents an element of the original list.&lt;/p&gt;

&lt;p&gt;This is one example of how functional languages can avoid using &lt;code&gt;for ...&lt;/code&gt; loop syntax making the language clearer. Mapping a function to a list is even more descriptive then a for loop!.&lt;/p&gt;

&lt;p&gt;Another way of avoid for loops is by means of recursion. Let&amp;rsquo;s go to the update function to see it.&lt;/p&gt;

&lt;h6 id=&#34;update&#34;&gt;update&lt;/h6&gt;

&lt;p&gt;Here you can see the code for the update function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elm&#34;&gt;-- UPDATE


type Msg
    = Change String
    | Select Hero


update : Msg -&amp;gt; Model -&amp;gt; Model
update msg model =
    case msg of
        Change newName -&amp;gt;
            case model.selectedHeroId of
                Nothing -&amp;gt;
                    model

                Just i -&amp;gt;
                    let
                        h =
                            getHero i model.heroes
                    in
                        { model | heroes = (replaceHero i (Hero h.id newName) model.heroes) }

        Select hero -&amp;gt;
            { model | selectedHeroId = Just hero.id }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since now Msg type has two constructors (we can interact with our application by selecting an hero from the list and by changing its name), we have to handle both cases.
Case for Change hero&amp;rsquo;s name hasn&amp;rsquo;t changed a lot. Model has been refactored so that we &amp;ldquo;update&amp;rdquo; the hero&amp;rsquo;s name when we have to change it. This is done by creating a new list (using the &lt;code&gt;replaceHero&lt;/code&gt; helping function).&lt;/p&gt;

&lt;p&gt;We have to build a new list because data in Elm are immutable: once defined a value, we cannot change it. All we can do is to assign a variable to a new value like we do with heroes assigning it to a new list containing updated information.&lt;/p&gt;

&lt;p&gt;Syntax &lt;code&gt;{ model | heroes = ... }&lt;/code&gt; is a syntactic sugar for &lt;code&gt;model = {selectedHeroId = mode.selectedHeroId, heroes = ... }&lt;/code&gt; and it does not change the value of the record in place.&lt;/p&gt;

&lt;p&gt;Code for &lt;code&gt;Select&lt;/code&gt; hero is also very simple: just an assignment to &lt;code&gt;SelectedHeroId&lt;/code&gt; with &lt;code&gt;Just&lt;/code&gt; constructor (pun intended).&lt;/p&gt;

&lt;p&gt;Through the code we saw some utility functions that helped in making the code more clear and concise. As we said earlier, factoring out small reusable functions is the key in having a nice Elm code that is easy to maintain and refactor.&lt;/p&gt;

&lt;p&gt;Here you can see two of them that shows how recursion can be used to iterate over a list.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elm&#34;&gt;-- UTILS


replaceHero : Int -&amp;gt; Hero -&amp;gt; List Hero -&amp;gt; List Hero
replaceHero i h hs =
    case hs of
        [] -&amp;gt;
            hs

        x :: xs -&amp;gt;
            if i == x.id then
                h :: xs
            else
                x :: (replaceHero i h xs)


getHero : Int -&amp;gt; List Hero -&amp;gt; Hero
getHero i heroes =
    case heroes of
        [] -&amp;gt;
            Debug.crash &amp;quot;Should never go here&amp;quot;

        x :: xs -&amp;gt;
            if x.id == i then
                x
            else
                getHero i xs

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s walk through the second one first. &lt;code&gt;getHero&lt;/code&gt; is a function that takes a hero id (Int) and a list of heroes and returns the hero object identified by the hero id we passed as first parameter.&lt;/p&gt;

&lt;p&gt;Function body uses the &lt;code&gt;case&lt;/code&gt; syntax to &lt;strong&gt;pattern match&lt;/strong&gt; against the List constructors. This basically means that an Elm List can be constructed either like an empty list (&lt;code&gt;[]&lt;/code&gt;) or by attaching an element to a second list (&lt;code&gt;x :: xs&lt;/code&gt;). Pattern match allows to express a function differently depending on the pattern that is matched.&lt;/p&gt;

&lt;p&gt;Looking at our function, we pattern match heroes against an empty list or against a list with at least one argument. Since the first case should never happen, we deliberately decide to make the application crash if matched. In the second case, we first check if the first element in the list (&lt;code&gt;x&lt;/code&gt;) is the element we were looking for. If yes we return it, otherwise we call recursively the same function on the rest of the list.&lt;/p&gt;

&lt;p&gt;Recursion is used also in the first example where we recursively build the new list of heroes with the new hero replaced in place of the old one (if found).&lt;/p&gt;

&lt;p&gt;It can take a while before thinking in terms of recursive problems becomes natural: we are so used to think in terms of loops! Thinking to a problem in terms of a similar, smaller and easier to solve problem usually represents a nice way to solve it, (even if it might be wired at the beginning).&lt;/p&gt;

&lt;h3 id=&#34;second-take-home-about-elm&#34;&gt;Second take home about Elm&lt;/h3&gt;

&lt;p&gt;A common topic in this post is about the possibility of missing data. Elm doesn&amp;rsquo;t have something like a null reference and what can be used to describe the lack of data is the &lt;code&gt;Maybe&lt;/code&gt; container. In this way we are forced to handle all cases explicitly, resulting in a much more reliable code.&lt;/p&gt;

&lt;p&gt;This is why in the &lt;code&gt;getHero&lt;/code&gt; function we had to handle the code for empty list even if we are sure that the application will never call it. But what happens if we remove that branch?
That is the error message we have from the compiler where we try to compile the code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-- MISSING PATTERNS ---- \TourOfElm\src\Main.elm

This `case` does not have branches for all possibilities.

102|&amp;gt;    case heroes of
103|&amp;gt;
104|&amp;gt;        x :: xs -&amp;gt;
105|&amp;gt;            if x.id == i then
106|&amp;gt;                x
107|&amp;gt;            else
108|&amp;gt;                getHero i xs

You need to account for the following values:

    []

Add a branch to cover this pattern!

If you are seeing this error for the first time, check out these hints:
&amp;lt;https://github.com/elm-lang/elm-compiler/blob/0.17.1/hints/missing-patterns.md&amp;gt;
The recommendations about wildcard patterns and `Debug.crash` are important!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we have to cover all possibilities. In this example, since we call the function on a selected hero, it doesn&amp;rsquo;s make sense to call this function with an &lt;code&gt;id&lt;/code&gt; that is not present in the list of heroes. Hence we call &lt;code&gt;Debug.crash&lt;/code&gt; to explicitly make crash the application in case of that code being called (something must have gone very bad somewhere and we better make the application crash right here instead of let it crash later).&lt;/p&gt;

&lt;p&gt;Getting rid of null reference is a great improvement in comparison to javascript, given what its inventor &lt;a href=&#34;https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare&#34;&gt;thinks&lt;/a&gt; about it.&lt;/p&gt;

&lt;p&gt;Those are some thoughts from Thomas Hoare, who introduced the Null reference in ALGOL language:&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;I call it my billion-dollar mistake! At that time, I was designing the first comprehensive type system for references in an object-oriented language. My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn&amp;rsquo;t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years. - Tony Hoare, inventor of ALGOL W.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Tour Of Elm - Part One</title>
      <link>https://tizpuppi.github.io/blog/tour_of_elm-part_one/</link>
      <pubDate>Sat, 15 Oct 2016 09:00:00 +0200</pubDate>
      
      <guid>https://tizpuppi.github.io/blog/tour_of_elm-part_one/</guid>
      <description>

&lt;p&gt;I Recently played with the &lt;a href=&#34;http://elm-lang.org/&#34;&gt;Elm&lt;/a&gt; programming language and I really enjoyed its elegance and cleanness. Elm is a strongly typed functional language, largely inspired by Haskell, that compiles to javascript. Code written in Elm usually follows a simple pattern called &lt;a href=&#34;https://guide.elm-lang.org/architecture/&#34;&gt;Elm architecture&lt;/a&gt; that helps to nicely structure your web application and that has inspired the Redux library for ReactJs.&lt;/p&gt;

&lt;p&gt;Having recently chosen Angular 2 as preferred front end framework at work, I was looking for a nice comparison between the two that could give me some insight about the different philosophies and approach to web development. Eventually I could even be better equipped to argue in favor of a functional not mainstream language!&lt;/p&gt;

&lt;p&gt;The problem with tutorials is that each tend to emphasize the strength of a particular language/library/framework, showing ad hoc examples where that particular language or library shines.&lt;/p&gt;

&lt;p&gt;For this reason I&amp;rsquo;ve chosen to implement the same &lt;a href=&#34;https://angular.io/docs/ts/latest/tutorial/&#34;&gt;tutorial&lt;/a&gt; for Angular 2 using Elm and since the original tutorial is pretty long, I&amp;rsquo;ve split it in several posts.&lt;/p&gt;

&lt;h1 id=&#34;angular-2-tutorial-in-elm-part-1&#34;&gt;Angular 2 Tutorial in Elm - Part 1&lt;/h1&gt;

&lt;h3 id=&#34;project-setup&#34;&gt;Project setup.&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;ve written this post and tested the code with version 0.17 of Elm and during this journey I will assume only a limited knowledge of the language. Previous exposure to Elm through the Elm tutorial will help to follow it. Anyway I will try to start gently so that even with limited knowledge you can have a global overview of the language.&lt;/p&gt;

&lt;p&gt;This article assumes you have already installed node, npm package manager and Elm on your machine. If it&amp;rsquo;s not the case you can give a look at &lt;a href=&#34;https://nodejs.org/en/&#34;&gt;nodejs&lt;/a&gt; and &lt;a href=&#34;http://elm-lang.org/&#34;&gt;elm-lang&lt;/a&gt; web sites.&lt;/p&gt;

&lt;p&gt;I will focus my comments mainly on Elm code, but the complete source code (including building and deploying scripts) is available on &lt;a href=&#34;https://github.com/tizpuppi/TourOfElm&#34;&gt;github&lt;/a&gt;. For this part of tutorial you can refer to branch &lt;a href=&#34;https://github.com/tizpuppi/TourOfElm/tree/01-HeroEditor&#34;&gt;01-HeroEditor&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;the-hero-editor-screen-only&#34;&gt;The Hero Editor - Screen only&lt;/h3&gt;

&lt;p&gt;In the first part we want to display a simple page with info about an hero. This page will have an input field where the user can change the hero name and automatically reflect this change on the page subtitle. Here is a screenshot of desired behaviour.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tizpuppi.github.io/images/HeroEditor.gif&#34; alt=&#34;Hero Editor Screenshot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start with showing the complete code of an application where there is no interaction with users.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elm&#34;&gt;module Main exposing (..)

import Html exposing (Html, div, h1, h2, label, input, text)
import Html.Attributes exposing (placeholder, value)
import Html.App as App


main : Program Never
main =
    App.beginnerProgram { model = model, view = view, update = update }


type alias AppConfig =
    { title : String }


config : AppConfig
config =
    { title = &amp;quot;Tour of Heroes&amp;quot; }



-- MODEL


type alias Hero =
    { id : Int, name : String }


type alias Model =
    { hero : Hero }


model : Model
model =
    { hero = { id = 1, name = &amp;quot;Windstorm&amp;quot; } }



-- UPDATE


type Msg
    = NoOp


update : Msg -&amp;gt; Model -&amp;gt; Model
update msg model =
    model



-- VIEW


view : Model -&amp;gt; Html Msg
view model =
    div []
        [ h1 [] [ text config.title ]
        , h2 [] [ text (model.hero.name ++ &amp;quot; details!&amp;quot;) ]
        , div []
            [ label [] [ text (&amp;quot;id: &amp;quot; ++ toString model.hero.id) ]
            ]
        , div []
            [ label [] [ text &amp;quot;name: &amp;quot; ]
            , input [ value model.hero.name, placeholder &amp;quot;name&amp;quot; ] []
            ]
        ]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A lot of stuff for a simple screen! But laying down the code following the Elm architecture will help in making the code evolve as we will advance adding more features.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s walk throw the code above.&lt;/p&gt;

&lt;p&gt;The first part is the module declaration &lt;code&gt;module Main exposing (..)&lt;/code&gt; where we declare a Main module exposing all top level functions and data types. Every file in Elm is a module and if there is no module declaration by default the compiler assumes that previous declaration is included.&lt;/p&gt;

&lt;p&gt;Then some imports follow. Import allows us to use some functions declared in other modules. I will not explain here all the details, but if you want to have more info you can have a look at the &lt;a href=&#34;https://guide.elm-lang.org/reuse/modules.html&#34;&gt;Elm official site&lt;/a&gt;. Let&amp;rsquo;s move now to the core of this simple application.&lt;/p&gt;

&lt;h6 id=&#34;model&#34;&gt;model&lt;/h6&gt;

&lt;p&gt;When coding in Elm the first thing I generally start with is the &lt;strong&gt;model&lt;/strong&gt;: this is the heart of the application&amp;rsquo;s logic! So let&amp;rsquo;s have a look to our model.&lt;/p&gt;

&lt;p&gt;In this case we start by creating a type alias &lt;code&gt;type alias Hero = {id: Int, name: String}&lt;/code&gt; to have a nicer name. What is in curly braces is called a record in Elm and it can be thought as a javascript object. Here we specify that an Hero object is made of two fields which in turn are of type Int and String. Those fields are the id and the name of our hero.&lt;/p&gt;

&lt;p&gt;Next let&amp;rsquo;s create an alias for the model itself. At this stage our Model type is simply a record with one Hero object inside &lt;code&gt;type alias Model = { hero : Hero }&lt;/code&gt;. At this point we can create the (initial) model: &lt;code&gt;{ hero = { id = 1, name = &amp;quot;Windstorm&amp;quot; } }&lt;/code&gt;: a single hero with id 1 and name &amp;ldquo;Windstorm&amp;rdquo;. We will pass this to the main application loop, as described later.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;As a side note: even if in the angular tutorial the page title belongs to the model, here I considered refactoring it into an application configuration. This because the title is something the user is not interacting with through all the angular tutorial and I think putting as configuration gives a better view on what it really is (immutable configuration data).&lt;/em&gt;&lt;/p&gt;

&lt;h6 id=&#34;view&#34;&gt;view&lt;/h6&gt;

&lt;p&gt;The second thing we better implement is the &lt;strong&gt;view&lt;/strong&gt;. In Elm there is no template language: the html is described in terms of functions being called, that is using the same language as the rest of the code. This has his pros and his cons, but personally, after a first time where I was having some difficulties in reading it, the more I work with the more I like this approach. I will come back later with some reflections on this topic. In general the code for the view is pretty straightforward and self-explanatory so I will not spend to much words on the view function.&lt;/p&gt;

&lt;h6 id=&#34;update&#34;&gt;update&lt;/h6&gt;

&lt;p&gt;Finally the code to &lt;strong&gt;update&lt;/strong&gt; the model. In this first part we don&amp;rsquo;t want to include any user interactions, so we define a dummy type Msg: &lt;code&gt;type Msg = NoOp&lt;/code&gt;. The left hand side is the type declaration, and the right hand side is the constructor list. Here we can declare multiple constructor, similar to the union type we find in other languages. Fot this small example we define a single dummy constructor &lt;code&gt;NoOp&lt;/code&gt; to mean that we don&amp;rsquo;t want to perform any update operation. Right now we don&amp;rsquo;t want to implement any user interaction, so the update function takes the current model and returns it.&lt;/p&gt;

&lt;p&gt;All three pieces of this application (model, view, update) are glued together in the App.beginnerProgram function. &lt;code&gt;main = App.beginnerProgram { model = model, view = view, update = update }&lt;/code&gt;This is the main function where the Elm runtime library plays its role: simply said, we can think of it as the responsible for refreshing the view, keeping it in sync with the model, and passing all messages to the update function.&lt;/p&gt;

&lt;h3 id=&#34;the-hero-editor-adding-interactions&#34;&gt;The Hero Editor - Adding interactions&lt;/h3&gt;

&lt;p&gt;Now that everything is in place, we need to add interactions with the users. For this we have to add an import for HTML events (we only want onInput event for the moment). Html.Events are much like javascript events callback with the difference that what we pass to the event is not a callback function like in javascript, but a message that will be passed to the update function in order to update the model and eventually refresh the view.&lt;/p&gt;

&lt;p&gt;Here you can see the part of the code that we had to change in order to achieve this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elm&#34;&gt;module Main exposing (..)

...
import Html.Events exposing (onInput)
...


-- UPDATE


type Msg
    = Change String


update : Msg -&amp;gt; Model -&amp;gt; Model
update msg model =
    case msg of
        Change newName -&amp;gt;
            let
                oldHero =
                    model.hero

                newHero =
                    { oldHero | name = newName }
            in
                { model | hero = newHero }



-- VIEW


view : Model -&amp;gt; Html Msg
view model =
      ...
        , div []
            [ label [] [ text &amp;quot;name: &amp;quot; ]
            , input [ value model.hero.name, placeholder &amp;quot;name&amp;quot;, onInput Change ] []
            ]
        ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;updating-update&#34;&gt;updating update&lt;/h6&gt;

&lt;p&gt;First we need to update the &lt;code&gt;Msg&lt;/code&gt; type, from the dummy &lt;code&gt;NoOp&lt;/code&gt; to &lt;code&gt;Change String&lt;/code&gt;. This means that when there will be some actions in the interface, a Msg of type &lt;code&gt;Change String&lt;/code&gt; will be create (for example &lt;code&gt;Change &amp;quot;Superman&amp;quot;&lt;/code&gt;). Then the update function extracts the payload associated with &lt;code&gt;Change Msg&lt;/code&gt; and replaces the model with the new information. First we check that the Msg was build using the Change constructor. This is done using a &lt;code&gt;case&lt;/code&gt; statement (similar to pattern matching in Haskell). Then with the new hero name a new hero record is build, and from there a new model record is created and returned (since is the last expression).&lt;/p&gt;

&lt;h6 id=&#34;immutable-data&#34;&gt;immutable data&lt;/h6&gt;

&lt;p&gt;Note here a fundamental difference between javascript and Elm language: since all data are immutable by default, we cannot simply change the value of an object (record in this case) but we have to build a new one and evaluate the newly created object. This may seem confusing at beginning but the combination immutable data + stateless functions allows avoiding buggy side effects making ultimately easier to refactor code.&lt;/p&gt;

&lt;p&gt;On the view side, we will use the onInput event. This event captures the string value associated with the input field, so that the new value is passed along with Change Msg to the update function.&lt;/p&gt;

&lt;h3 id=&#34;first-take-home-about-elm&#34;&gt;First take home about Elm&lt;/h3&gt;

&lt;p&gt;The first take home about Elm is the lack of template language. This is how Evan Czaplicki (creator of Elm language) explains it in the &lt;a href=&#34;https://groups.google.com/forum/#!topic/elm-discuss/uXjcVyZ5IYo&#34;&gt;Elm discussion group&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;It&amp;rsquo;s nice that the full power of Elm is available with elm-html. No special syntax is needed, it&amp;rsquo;s easy to use lists or dictionaries or functions or whatever else, and you get type checking very easily.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;and also&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;I guess this is controversial, but my feeling is that templating languages tend to evolve into bad languages. What I mean is, there&amp;rsquo;s a pull towards accidental turing-completeness. &amp;ldquo;Wouldn&amp;rsquo;t it be nice to have a for loop?&amp;rdquo; and it gets added. &amp;ldquo;Wouldn&amp;rsquo;t it be nice to have if statements?&amp;rdquo; &amp;ldquo;What about when I want an expression from the host language?&amp;rdquo; {{ normal stuff }} Eventually you have embedded a whole new language in an existing language! And worse, that embedded language is probably fairly haphazard and limited.),&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;For me those words were very illuminating! When it comes to loop or if clauses, the language syntax itself is the best tool to handle those needs. The initial weirdness that we have when coding html using functions is given by the fact that we are so used to associate angular brackets with html that we might feel having more difficulties at parsing with our eyes a piece of Elm code in place of some &lt;em&gt;templated&lt;/em&gt; html. Personally, after some time, I found very clear to read Elm code that describes html views, especially when nicely indented using the Elm syntax guide&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Since we touched the loop subject, let&amp;rsquo;s move to the next post to see how functional language deal with it without using any &lt;code&gt;for ...&lt;/code&gt; loop syntax&amp;hellip;&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;See &lt;a href=&#34;https://github.com/avh4/elm-format&#34;&gt;elm-format&lt;/a&gt; from example. This is a very nice tool that formats Elm source code according to a standard set of rules. Styling wars among developer working on the same code base will not exist anymore!
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>