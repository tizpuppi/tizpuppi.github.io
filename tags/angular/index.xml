<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Angular on tizpuppi</title>
    <link>https://tizpuppi.github.io/tags/angular/</link>
    <description>Recent content in Angular on tizpuppi</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 07 Nov 2016 09:00:00 +0100</lastBuildDate>
    <atom:link href="https://tizpuppi.github.io/tags/angular/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Tour Of Elm - Part Three</title>
      <link>https://tizpuppi.github.io/blog/tour_of_elm-part_three/</link>
      <pubDate>Mon, 07 Nov 2016 09:00:00 +0100</pubDate>
      
      <guid>https://tizpuppi.github.io/blog/tour_of_elm-part_three/</guid>
      <description>

&lt;h1 id=&#34;angular-2-tutorial-in-elm-part-3&#34;&gt;Angular 2 Tutorial in Elm - Part 3&lt;/h1&gt;

&lt;h3 id=&#34;the-external-world&#34;&gt;The external world&lt;/h3&gt;

&lt;p&gt;We have smoothly built our application up to this point but still we are playing in insulation: once loaded, everything is there and no communication is done with the external world. This is perfect if we want to have a fancy single page application with some animation, but sometimes what we want to display depends on some information available remotely.&lt;/p&gt;

&lt;p&gt;In this is part we will deal with remote server communication and we will build on top of what we have done in the previous &lt;a href=&#34;https://tizpuppi.github.io/blog/tour_of_elm-part_one/&#34;&gt;two&lt;/a&gt; &lt;a href=&#34;https://tizpuppi.github.io/blog/tour_of_elm-part_two/&#34;&gt;posts&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;let-s-grow-a-bit&#34;&gt;Let&amp;rsquo;s grow a bit&lt;/h3&gt;

&lt;p&gt;The main function, responsible for gluing the model, the view, and the update function (via the Elm Architecture pattern), is &lt;code&gt;beginnerProgram&lt;/code&gt; from &lt;code&gt;Html.App&lt;/code&gt; module. As its name suggests, this function is suitable for simple applications, that do not need to handle external communication.&lt;/p&gt;

&lt;p&gt;Operations that not only affects our model but that also send messages to the outside, or listen to incoming messages, make use of &lt;code&gt;Commands&lt;/code&gt; and &lt;code&gt;Subscriptions&lt;/code&gt;. In this tutorial we will not use subscriptions (those are especially useful for real-time communication using web sockets), but will use commands which in Elm have type &lt;code&gt;Cmd&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To integrate Commands and Subscriptions in our code, we have to extend the Elm Architecture pattern, using the gluing function &lt;code&gt;program&lt;/code&gt;  also located in the &lt;code&gt;Html.App&lt;/code&gt; module. Both &lt;code&gt;beginnerProgram&lt;/code&gt; and &lt;code&gt;program&lt;/code&gt; functions take a record as parameter but the latter is a bit more sophisticated: here a list of items &lt;code&gt;program&lt;/code&gt; expects to receive as input:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elm&#34;&gt;App.program { init = init, view = view, update = update, subscriptions = subscriptions }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;init&lt;/strong&gt; is an initial expression that program uses to bootstrap the application.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;view&lt;/strong&gt; is the usual view function as in the &lt;code&gt;beginnerProgram&lt;/code&gt; case&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;update&lt;/strong&gt; has the same meaning as in &lt;code&gt;beginnerProgram&lt;/code&gt; case, but its signature changes as we will see briefly.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;subscriptions&lt;/strong&gt; is used to listen to external events (coming from outside the application)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here you can find the signature for these functions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elm&#34;&gt;init : ( Model, Cmd Msg )
view : Model -&amp;gt; Html Msg
update : Msg -&amp;gt; Model -&amp;gt; ( Model, Cmd Msg )
subscriptions : Model -&amp;gt; Sub Msg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The most important change is in the update function: the return type is not only the updated model, but also a command to be performed. Similarly, we do not bootstrap the application giving an initial model, but we give a tuple composed by an initial model and an initial command to be performed at the very beginning.&lt;/p&gt;

&lt;p&gt;As usual I will refer to my &lt;a href=&#34;https://github.com/tizpuppi/TourOfElm&#34;&gt;github&lt;/a&gt; repository, building from where we left in the previous post (branch 02-HeroList). I will show here the changes in order to upgrade from beginnerProgram to Program:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elm&#34;&gt;App.beginnerProgram { model = initialModel, view = view, update = update }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;becomes&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elm&#34;&gt;App.program { init = init, view = view, update = update, subscriptions = subscriptions }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the new init function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elm&#34;&gt;init : ( Model, Cmd Msg )
init =
    initialModel ! [ Cmd.none ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No command must be issued for the moment, so we simply add to the initialModel, the command &lt;code&gt;Cmd.none&lt;/code&gt; (empty command). The &lt;code&gt;!&lt;/code&gt; operator is a syntactic sugar for &lt;code&gt;(Model, Cmd Msg)&lt;/code&gt; tuple. It takes a model on the left and a list of commands on the right returning a tuple of type &lt;code&gt;(Model, Cmd Msg)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The update function also changes signature:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elm&#34;&gt;update : Msg -&amp;gt; Model -&amp;gt; ( Model, Cmd Msg )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and instead of returning an updated &lt;code&gt;model&lt;/code&gt; expression, now we return &lt;code&gt;model ! [ Cmd.none]&lt;/code&gt;, as in the initial expression.&lt;/p&gt;

&lt;p&gt;Finally the subscriptions code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elm&#34;&gt;subscriptions : Model -&amp;gt; Sub Msg
subscriptions model =
    Sub.none
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since we do not use subscription here, we take as input the model and we return the special subscription &lt;code&gt;Sub.none&lt;/code&gt; (empty subscription).&lt;/p&gt;

&lt;h3 id=&#34;server-here-we-have&#34;&gt;Server? Here we have&lt;/h3&gt;

&lt;p&gt;Talking to a server means we need a server! Being a tutorial about a front end technology we want to focus on this side of a web application. This is why in most tutorials the back end is often simulated using an in memory structure. However it would be nice to develop with something that is as closer as possible to a real server. This is where json-server comes in.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;json-server&lt;/code&gt; is a &lt;a href=&#34;https://github.com/typicode/json-server&#34;&gt;javascript package&lt;/a&gt; that provides a fake rest api server. It implements a server reading a simple json file and can be installed by typing &lt;code&gt;npm install json-server --save&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here you can see the file where all information about our heroes are stored. This file is read by json-server so that we will be able to query it and receive those information in json format.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;heroes&amp;quot;: [
    {
      &amp;quot;id&amp;quot;: 11,
      &amp;quot;name&amp;quot;: &amp;quot;Mr. Nice&amp;quot;
    },
    {
      &amp;quot;id&amp;quot;: 12,
      &amp;quot;name&amp;quot;: &amp;quot;Narco&amp;quot;
    },
    {
      &amp;quot;id&amp;quot;: 13,
      &amp;quot;name&amp;quot;: &amp;quot;Bombasto&amp;quot;
    },
    {
      &amp;quot;id&amp;quot;: 14,
      &amp;quot;name&amp;quot;: &amp;quot;Celeritas&amp;quot;
    },
    {
      &amp;quot;id&amp;quot;: 15,
      &amp;quot;name&amp;quot;: &amp;quot;Magneta&amp;quot;
    },
    {
      &amp;quot;id&amp;quot;: 16,
      &amp;quot;name&amp;quot;: &amp;quot;RubberMan&amp;quot;
    },
    {
      &amp;quot;id&amp;quot;: 17,
      &amp;quot;name&amp;quot;: &amp;quot;Dynama&amp;quot;
    },
    {
      &amp;quot;id&amp;quot;: 18,
      &amp;quot;name&amp;quot;: &amp;quot;Dr IQ&amp;quot;
    },
    {
      &amp;quot;id&amp;quot;: 19,
      &amp;quot;name&amp;quot;: &amp;quot;Magma&amp;quot;
    },
    {
      &amp;quot;id&amp;quot;: 20,
      &amp;quot;name&amp;quot;: &amp;quot;Tornado&amp;quot;
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to launch it we have to simply type &lt;code&gt;json-server --watch server/db.json&lt;/code&gt; assuming that we have stored the file above named as db.json in a folder named server.&lt;/p&gt;

&lt;h3 id=&#34;hello-server&#34;&gt;Hello server!&lt;/h3&gt;

&lt;p&gt;Up to know we have only set all what was necessary to fetch data from a remote server. Now it&amp;rsquo;s time to implement actual code.&lt;/p&gt;

&lt;p&gt;Elm doesn&amp;rsquo;t have the http module installed by default. In order to install we have to install the &lt;code&gt;evancz/elm-http&lt;/code&gt; package by typing &lt;code&gt;elm package install evancz/elm-http&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s jumps to the code and see how a GET request is performed:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elm&#34;&gt;getHeroes : Cmd Msg
getHeroes =
    let
        url =
            &amp;quot;http://localhost:3000/heroes&amp;quot;
    in
        Task.perform FetchFail FetchSucceed (Http.get decodeUrl url)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After installing json-server and running it, we can fetch Heroes list directly from the server. &lt;code&gt;getHeroes&lt;/code&gt; does the asynchronous call using the Task module.&lt;/p&gt;

&lt;p&gt;As we sad earlier, commands are used to perform activities that involve side effects (like talking to a server for example). But commands are simply a description of the operation that have to be performed: a command have to be executed and one way to do it is by means of asynchronous operations that can succeed or fail. Tasks serve to this purpose and they are similar to promises in JavaScript. &lt;code&gt;Cmd&lt;/code&gt; and &lt;code&gt;Task&lt;/code&gt; are not easy to grasp at the beginning and you can refer to the &lt;a href=&#34;http://package.elm-lang.org/packages/elm-lang/core/latest/Platform-Cmd&#34;&gt;documentation&lt;/a&gt; to have more info. Nevertheless it is easier to understand these concepts if first you see them in action.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Task.perform&lt;/code&gt; instructs the runtime system to perform a task. In the code above we specify in the first two positions the messages to pass to the runtime in case of failure or success of the asynchronous operation. Below you can see the definition of the two new messages &lt;code&gt;FetchFail&lt;/code&gt; and &lt;code&gt;FetchSucceed&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elm&#34;&gt;type Msg
    = Change String
    | Select Hero
    | FetchFail Http.Error
    | FetchSucceed (List Hero)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally the last argument it the task to be executed itself. &lt;code&gt;Http.get&lt;/code&gt; takes as arguments a decoder function, to decode the received message, and a string containing the ulr where to perform the GET request. It then returns the task that &lt;code&gt;Task.perform&lt;/code&gt; will execute. In our case &lt;code&gt;url&lt;/code&gt; is pointing to localhost, port 3000, because this is the default port of json-server.&lt;/p&gt;

&lt;p&gt;In case of failure, a message of type &lt;code&gt;FetchFail&lt;/code&gt; is passed to the application along with an error code. If we look at the documentation of the Http module, we can see &lt;code&gt;Http.Error&lt;/code&gt; defined as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elm&#34;&gt;type Error
    = Timeout
    | NetworkError
    | UnexpectedPayload String
    | BadResponse Int String
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In case of success, a new List of Hero is passed as payload to the message &lt;code&gt;FetchSucceed&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here &lt;code&gt;decodeUrl&lt;/code&gt; is the function that transforms our json response into an Elm object. This is how we defined it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elm&#34;&gt;decodeUrl : Json.Decoder (List Hero)
decodeUrl =
    let
        hero =
            Json.object2 (\id name -&amp;gt; Hero id name)
                (&amp;quot;id&amp;quot; := Json.int)
                (&amp;quot;name&amp;quot; := Json.string)
    in
        Json.list hero
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our list of Heroes is made of Hero objects, so the first part of the function definition deals with the problem of decoding each element of the json array into a Hero object.&lt;/p&gt;

&lt;p&gt;Json module, imported at the beginning of the code, has all the ingredients to perform this operation. The trick to understand this piece of code is the fact that we are composing different decoders to form a more complex one.&lt;/p&gt;

&lt;p&gt;In the guide for Json module, &lt;code&gt;Json.Decoder&lt;/code&gt; is defined as &lt;code&gt;type Decoder a&lt;/code&gt;: this means that it is a parametric type. In our code we assigned the type &lt;code&gt;List Hero&lt;/code&gt; to the parameter.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Json.list&lt;/code&gt; is the functions that decodes a javascript array into an Elm List using the decoder given as first argument: this will be the decoder used for every item in the array. In our case we defined above such decoder called &lt;code&gt;hero&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s move to analyze the first decoder. The story for &lt;code&gt;Json.object2&lt;/code&gt; function is similar to the one we just saw. This is a decoder used to decode a json object with exactly two fields and that takes a function as first argument, and two more decoders. The latter are used to decode each field, while the function, given as first parameter, is used to build an Elm object from the decoded json object&amp;rsquo;s elements.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Json.int&lt;/code&gt; and &lt;code&gt;Json.string&lt;/code&gt; are two decoders that decode primitive json elements in primitive Elm types (&lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt;). Finally the &lt;code&gt;:=&lt;/code&gt; operator (defined by Json module) is used again to compose a Json decoder with a string and is used to decode the field names in a json object.&lt;/p&gt;

&lt;p&gt;Almost done!&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s now complete what is missing: the update function must take into account the two new messages that we have defined earlier.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elm&#34;&gt;        FetchFail _ -&amp;gt;
            model
                ! [ Cmd.none ]

        FetchSucceed heroes -&amp;gt;
            { model | heroes = heroes }
                ! [ Cmd.none ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example in case of failure we return the same model for simplicity. This is just a personal choice, but in production code it is likely that you want to change the model in order to display some error message to the user.&lt;/p&gt;

&lt;p&gt;In case of success, once a new list of Heroes has been retrieved, we simply use it to define the new model and display the retrieved data.&lt;/p&gt;

&lt;p&gt;Now that everything is set up, we need to trigger the initial call to the server by changing the initial command from &lt;code&gt;Cmd.none&lt;/code&gt; to &lt;code&gt;getHeroes&lt;/code&gt;. Here you can see the new init function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elm&#34;&gt;init : ( Model, Cmd Msg )
init =
    initialModel ! [ getHeroes ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And since we retrieve the list of heroes from the server, we do not need anymore to define this list in the code. Our initial model can use an empty list as initial value for the list of heroes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elm&#34;&gt;initialModel : Model
initialModel =
    { selectedHeroId = Nothing, heroes = [] }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The complete code is available as usual in the &lt;a href=&#34;https://github.com/tizpuppi/TourOfElm&#34;&gt;github&lt;/a&gt; repository in branch &lt;code&gt;03-FetchFromRemote&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;third-take-home-about-elm&#34;&gt;Third take home about Elm&lt;/h3&gt;

&lt;p&gt;Type is your fiend! Really!!&lt;/p&gt;

&lt;p&gt;When I first started writing Elm code, I immediately felt in love with its type system: it is really there to help you to write correct code.&lt;/p&gt;

&lt;p&gt;Type system in Elm is very different from types in a typical strong typed language because types are inferred from the code: Elm compiler is able to deduce variables type by looking at how that variable is used. This also means that type annotation are not mandatory (but strongly suggested).&lt;/p&gt;

&lt;p&gt;This comes handy for example when coding with parametric types, like we did with Json Decoder. If we change &lt;code&gt;decodeUrl&lt;/code&gt; function with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elm&#34;&gt;decodeUrl : Json.Decoder (List Hero)
decodeUrl =
    let
        hero =
            Json.object2 (\id name -&amp;gt; Hero id name)
                (&amp;quot;id&amp;quot; := Json.string)
                (&amp;quot;name&amp;quot; := Json.string)
    in
        Json.list hero
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and try to compile, we see a compile error like this one:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-- TYPE MISMATCH ------- /TourOfElm/src/Update.elm

The 2nd argument to function `object2` is causing a mismatch.

86|             Json.object2 (\id name -&amp;gt; Hero id name)
87|&amp;gt;                (&amp;quot;id&amp;quot; := Json.string)
88|                 (&amp;quot;name&amp;quot; := Json.string)

Function `object2` is expecting the 2nd argument to be:

    Json.Decoder Int

But it is:

    Json.Decoder String

Hint: I always figure out the type of arguments from left to right. If an
argument is acceptable when I check it, I assume it is &amp;quot;correct&amp;quot; in subsequent
checks. So the problem may actually be in how previous arguments interact with
the 2nd.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, the compiler correctly deduced the type parameter used for Decoder of the &lt;code&gt;id&lt;/code&gt; variable by knowing that the Hero constructor expects &lt;code&gt;id&lt;/code&gt; to be of type &lt;code&gt;Int&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note also how the error message is really human friendly and easy to understand compared to other languages. This is really a great feature that plays in favor of Elm language (and compiler) and it has been a clear obsession of Elm&amp;rsquo;s &amp;ldquo;father&amp;rdquo; Evan Czaplicki.&lt;/p&gt;

&lt;p&gt;As he &lt;a href=&#34;http://elm-lang.org/blog/compiler-errors-for-humans&#34;&gt;once&lt;/a&gt; said:&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Ease of use is a major priority in Elm, so I recently took a couple weeks to really focus on this. I learned that you can make a shockingly huge difference just by thinking about the user experience.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;Its very nice to see how a compiler can be written with the user in mind helping the developer with useful hints and giving finally the developer a tool that helps refactoring the code without introducing new bugs.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Tour Of Elm - Part Two</title>
      <link>https://tizpuppi.github.io/blog/tour_of_elm-part_two/</link>
      <pubDate>Fri, 28 Oct 2016 09:00:00 +0200</pubDate>
      
      <guid>https://tizpuppi.github.io/blog/tour_of_elm-part_two/</guid>
      <description>

&lt;h1 id=&#34;angular-2-tutorial-in-elm-part-2&#34;&gt;Angular 2 Tutorial in Elm - Part 2&lt;/h1&gt;

&lt;h3 id=&#34;let-s-scale-multiple-heroes&#34;&gt;Let&amp;rsquo;s scale: multiple heroes&lt;/h3&gt;

&lt;p&gt;We are ready to continue our journey of the angular 2 tutorial in Elm. We have touched a bit the Elm architecture in the &lt;a href=&#34;https://tizpuppi.github.io/blog/tour_of_elm-part_one/&#34;&gt;previous post&lt;/a&gt; and we are now ready to build on it. We left the application at the point where there was one hero displayed on the page and we were able to nicely change its name.&lt;/p&gt;

&lt;p&gt;Now it&amp;rsquo;s time to grow and we want to scale this feature on multiple heroes, showing a list of heroes among which we can choose, and changing its name once selected. Here you can see a screenshot of the desired behaviour:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tizpuppi.github.io/images/HeroList.gif&#34; alt=&#34;Hero List Screenshot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As usual all code is available in the &lt;a href=&#34;https://github.com/tizpuppi/TourOfElm&#34;&gt;github&lt;/a&gt; repository: for this post you can refer to branch 02-HeroList.&lt;/p&gt;

&lt;p&gt;We will build on top of the code we wrote for the previous post.&lt;/p&gt;

&lt;h6 id=&#34;model&#34;&gt;model&lt;/h6&gt;

&lt;p&gt;Let&amp;rsquo;s start by refactoring the model:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elm&#34;&gt;-- MODEL


type alias Hero =
    { id : Int, name : String }


heroes : List Hero
heroes =
    [ Hero 11 &amp;quot;Mr. Nice&amp;quot;
    , Hero 12 &amp;quot;Narco&amp;quot;
    , Hero 13 &amp;quot;Bombasto&amp;quot;
    , Hero 14 &amp;quot;Celeritas&amp;quot;
    , Hero 15 &amp;quot;Magneta&amp;quot;
    , Hero 16 &amp;quot;RubberMan&amp;quot;
    , Hero 17 &amp;quot;Dynama&amp;quot;
    , Hero 18 &amp;quot;Dr IQ&amp;quot;
    , Hero 19 &amp;quot;Magma&amp;quot;
    , Hero 20 &amp;quot;Tornado&amp;quot;
    ]


type alias Model =
    { selectedHeroId : Maybe Int, heroes : List Hero }


initialModel : Model
initialModel =
    { selectedHeroId = Nothing, heroes = heroes }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;THe Hero type alias doesn&amp;rsquo;t change from the previous version, but now the Model type alias is defined as a record containing the id of the selected hero (if any) and a list of heroes (defined separately for sake of clarity).&lt;/p&gt;

&lt;p&gt;In Elm, like in other functional languages, List is a key data structure. Lists are iterable containers containing data of the same type and are often used to transform data or perform computations over them: we&amp;rsquo;ll see later an example of this in action when transforming a list of Heroes into a list of Html objects.&lt;/p&gt;

&lt;p&gt;The second interesting Elm feature is that there is no null value. This is quite a revolution if compared to javascript, and I tend to believe that this is one of Elm&amp;rsquo;s greatest feature.&lt;/p&gt;

&lt;p&gt;Not having any null reference has some implications, like that if we want to describe the lack of value we have to explicitly describe it through a type. In Elm this is done using the &lt;strong&gt;Maybe&lt;/strong&gt; type.&lt;/p&gt;

&lt;p&gt;Maybe is a container similar to a list. The only difference is that it can contain 0 or 1 value, while a list can contain 0 or more values of the same type. Being a container, Maybe is a parametric type: we can have Maybe Int, or Maybe String or Maybe WhatEverYouWant. Normally the parameter is denoted with lower case letter, like &lt;strong&gt;Maybe a&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Maybe a has two constructors: &lt;strong&gt;Nothing&lt;/strong&gt; that indicates the lack of value, and &lt;strong&gt;Just a&lt;/strong&gt;: for example &lt;em&gt;Just 5&lt;/em&gt; has type &lt;em&gt;Maybe Int&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;As showed in the code above, we use Maybe Int to describe the id of selected item (or lack of selection).&lt;/p&gt;

&lt;h6 id=&#34;view&#34;&gt;view&lt;/h6&gt;

&lt;p&gt;Let&amp;rsquo;s now have a look at the view:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elm&#34;&gt;-- VIEW


showDetail : Model -&amp;gt; Html Msg
showDetail model =
    case model.selectedHeroId of
        Nothing -&amp;gt;
            text &amp;quot;&amp;quot;

        Just i -&amp;gt;
            div []
                [ h2 []
                    [ text ((getHero i model.heroes).name ++ &amp;quot; details!&amp;quot;)
                    ]
                , div []
                    [ label [] [ text (&amp;quot;id: &amp;quot; ++ toString i) ]
                    ]
                , div []
                    [ label [] [ text &amp;quot;name: &amp;quot; ]
                    , input
                        [ value (getHero i model.heroes).name
                        , placeholder &amp;quot;name&amp;quot;
                        , onInput Change
                        ]
                        []
                    ]
                ]


showList : Model -&amp;gt; List (Html Msg)
showList model =
    List.map
        (\e -&amp;gt;
            li
                [ onClick (Select e)
                , if isHeroSelected model.selectedHeroId e then
                    (class &amp;quot;selected&amp;quot;)
                  else
                    class &amp;quot;&amp;quot;
                ]
                [ span [ class &amp;quot;badge&amp;quot; ] [ text (toString e.id) ], text e.name ]
        )
        model.heroes


view : Model -&amp;gt; Html Msg
view model =
    body []
        [ h1 [] [ text config.title ]
        , h2 [] [ text &amp;quot;My Heroes&amp;quot; ]
        , ul [ class &amp;quot;items&amp;quot; ] (showList model)
        , showDetail model
        ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we start reading from the last function (view), it&amp;rsquo;s pretty clear what this function does: it displays the title in a header, a sub-header, a list and some details.&lt;/p&gt;

&lt;p&gt;Here we can learn another important lesson stated in the Elm Architecture Guide:&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;We do not think in terms of reusable components. Instead, we focus on reusable functions. It is a functional language after all!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is a pattern we will see through the whole tutorial: we will split our application by isolating small functions in modules. We prefer function composition over components assembling, especially when we are dealing conceptually with one subject (aka one model) like a list of heroes. Structuring an application by means of reusable components is still possible in Elm, but this approach is only suggested when each component is a really standalone piece with its own life (aka state or model in Elm terminology).&lt;/p&gt;

&lt;p&gt;As anticipated earlier, in this snippet of code we can also see how List is used to transform data from Model to Html. List.map is an Elm core utility function that takes a function and a list and returns a new list with the function applied to every element of the original list. Here the functions is an anonymous function: syntax for anonymous functions is  &lt;code&gt;(\e -&amp;gt; ... )&lt;/code&gt; where &lt;code&gt;e&lt;/code&gt; is the input parameter and in this case represents an element of the original list.&lt;/p&gt;

&lt;p&gt;This is one example of how functional languages can avoid using &lt;code&gt;for ...&lt;/code&gt; loop syntax making the language clearer. Mapping a function to a list is even more descriptive then using a &lt;code&gt;for&lt;/code&gt; loop!.&lt;/p&gt;

&lt;p&gt;Another way to avoid &lt;code&gt;for&lt;/code&gt; loops is by means of recursion. Let&amp;rsquo;s go to the update function to see it.&lt;/p&gt;

&lt;h6 id=&#34;update&#34;&gt;update&lt;/h6&gt;

&lt;p&gt;Here you can see the code for the update function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elm&#34;&gt;-- UPDATE


type Msg
    = Change String
    | Select Hero


update : Msg -&amp;gt; Model -&amp;gt; Model
update msg model =
    case msg of
        Change newName -&amp;gt;
            case model.selectedHeroId of
                Nothing -&amp;gt;
                    model

                Just i -&amp;gt;
                    let
                        h =
                            getHero i model.heroes
                    in
                        { model | heroes = (replaceHero i (Hero h.id newName) model.heroes) }

        Select hero -&amp;gt;
            { model | selectedHeroId = Just hero.id }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since now Msg type has two constructors (we can interact with our application by selecting an hero from the list and by changing its name), we have to handle both cases.
Case for Change hero&amp;rsquo;s name hasn&amp;rsquo;t changed a lot. The Model has been refactored so that we &amp;ldquo;update&amp;rdquo; the hero&amp;rsquo;s name when we have to change it. This is done by creating a new list (using the &lt;code&gt;replaceHero&lt;/code&gt; helping function).&lt;/p&gt;

&lt;p&gt;We have to build a new list because data in Elm are immutable: once a value has been defined, we cannot change it. All we can do is to assign a variable to a new value as we do with heroes assigning it to a new list containing updated information.&lt;/p&gt;

&lt;p&gt;Syntax &lt;code&gt;{ model | heroes = ... }&lt;/code&gt; is a syntactic sugar for &lt;code&gt;model = {selectedHeroId = mode.selectedHeroId, heroes = ... }&lt;/code&gt; and it does not change the value of the record in place.&lt;/p&gt;

&lt;p&gt;Code for &lt;code&gt;Select&lt;/code&gt; hero is also very simple: just an assignment to &lt;code&gt;SelectedHeroId&lt;/code&gt; with &lt;code&gt;Just&lt;/code&gt; constructor (pun intended).&lt;/p&gt;

&lt;p&gt;Through the code we saw some utility functions that helped making the code more clear and concise. As we said earlier, factoring out small reusable functions is the key for having a nice Elm code that is easy to maintain and refactor.&lt;/p&gt;

&lt;p&gt;Here you can see two of them that show how recursion can be used to iterate over a list.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elm&#34;&gt;-- UTILS


replaceHero : Int -&amp;gt; Hero -&amp;gt; List Hero -&amp;gt; List Hero
replaceHero i h hs =
    case hs of
        [] -&amp;gt;
            hs

        x :: xs -&amp;gt;
            if i == x.id then
                h :: xs
            else
                x :: (replaceHero i h xs)


getHero : Int -&amp;gt; List Hero -&amp;gt; Hero
getHero i heroes =
    case heroes of
        [] -&amp;gt;
            Debug.crash &amp;quot;Should never go here&amp;quot;

        x :: xs -&amp;gt;
            if x.id == i then
                x
            else
                getHero i xs

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s walk through the second one first. &lt;code&gt;getHero&lt;/code&gt; is a function that takes a hero id (Int) and a list of heroes and returns the hero object identified by the hero id we passed as first parameter.&lt;/p&gt;

&lt;p&gt;Function body uses the &lt;code&gt;case&lt;/code&gt; syntax to &lt;strong&gt;pattern match&lt;/strong&gt; against the List constructors. This basically means that an Elm List can be constructed either like an empty list (&lt;code&gt;[]&lt;/code&gt;) or by attaching an element to a second list (&lt;code&gt;x :: xs&lt;/code&gt;). Pattern match allows to express a function differently depending on the pattern that is matched.&lt;/p&gt;

&lt;p&gt;Looking at our function, we pattern match heroes against an empty list or against a list with at least one argument. Since the first case should never happen, we deliberately decide to make the application crash if matched. In the second case, we first check if the first element in the list (&lt;code&gt;x&lt;/code&gt;) is the element we were looking for. If yes we return it, otherwise we call recursively the same function on the rest of the list.&lt;/p&gt;

&lt;p&gt;Recursion is used also in the first example where we recursively build the new list of heroes with the new hero replacing the old one (if found).&lt;/p&gt;

&lt;p&gt;It can take a while before thinking in terms of recursive problems becomes natural: we are so used to think in terms of loops! Thinking about a problem in terms of a similar, smaller and easier to solve problem usually represents a nice way to solve it, (even if it might be wired at the beginning).&lt;/p&gt;

&lt;h3 id=&#34;second-take-home-about-elm&#34;&gt;Second take home about Elm&lt;/h3&gt;

&lt;p&gt;A common topic in this post is about the possibility of missing data. Elm doesn&amp;rsquo;t have something like a null reference and what can be used to describe the lack of data is the &lt;code&gt;Maybe&lt;/code&gt; container. In this way we are forced to handle all cases explicitly, resulting in a much more reliable code.&lt;/p&gt;

&lt;p&gt;This is why in the &lt;code&gt;getHero&lt;/code&gt; function we had to handle the code for empty list even if we are sure that the application will never call it. But what happens if we remove that branch?
This is the error message we have from the compiler where we try to compile the code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-- MISSING PATTERNS ---- \TourOfElm\src\Main.elm

This `case` does not have branches for all possibilities.

102|&amp;gt;    case heroes of
103|&amp;gt;
104|&amp;gt;        x :: xs -&amp;gt;
105|&amp;gt;            if x.id == i then
106|&amp;gt;                x
107|&amp;gt;            else
108|&amp;gt;                getHero i xs

You need to account for the following values:

    []

Add a branch to cover this pattern!

If you are seeing this error for the first time, check out these hints:
&amp;lt;https://github.com/elm-lang/elm-compiler/blob/0.17.1/hints/missing-patterns.md&amp;gt;
The recommendations about wildcard patterns and `Debug.crash` are important!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we have to cover all possibilities. In this example, since we call the function on a selected hero, it doesn&amp;rsquo;s make sense to call this function with an &lt;code&gt;id&lt;/code&gt; that is not present in the list of heroes. Hence we call &lt;code&gt;Debug.crash&lt;/code&gt; to explicitly make the application crash in case that code called (something must have gone very bad somewhere and we better make the application crash right here instead of let it crash later).&lt;/p&gt;

&lt;p&gt;Getting rid of null reference is a great improvement in comparison to javascript, given what its inventor &lt;a href=&#34;https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare&#34;&gt;thinks&lt;/a&gt; about it.&lt;/p&gt;

&lt;p&gt;Those are some thoughts from Thomas Hoare, who introduced the Null reference in ALGOL language:&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;I call it my billion-dollar mistake! At that time, I was designing the first comprehensive type system for references in an object-oriented language. My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn&amp;rsquo;t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years. - Tony Hoare, inventor of ALGOL W.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Tour Of Elm - Part One</title>
      <link>https://tizpuppi.github.io/blog/tour_of_elm-part_one/</link>
      <pubDate>Sat, 15 Oct 2016 09:00:00 +0200</pubDate>
      
      <guid>https://tizpuppi.github.io/blog/tour_of_elm-part_one/</guid>
      <description>

&lt;p&gt;I Recently played with the &lt;a href=&#34;http://elm-lang.org/&#34;&gt;Elm&lt;/a&gt; programming language and I really enjoyed its elegance and cleanness. Elm is a strongly typed functional language, largely inspired by Haskell, that compiles to javascript. Code written in Elm usually follows a simple pattern called &lt;a href=&#34;https://guide.elm-lang.org/architecture/&#34;&gt;Elm architecture&lt;/a&gt; that helps to nicely structure your web application and that has inspired the Redux library for ReactJs.&lt;/p&gt;

&lt;p&gt;Having recently chosen Angular 2 as preferred front end framework at work, I was looking for a nice comparison between the two frameworks that could give me some insights about the different philosophies and approaches to web development. Eventually I could even be better equipped to argue in favor of a functional, not-mainstream language!&lt;/p&gt;

&lt;p&gt;The problem with tutorials is that each tend to emphasize the strength of a particular language/library/framework, showing ad hoc examples where that particular language or library shines.&lt;/p&gt;

&lt;p&gt;For this reason I&amp;rsquo;ve decided to implement the existing &lt;a href=&#34;https://angular.io/docs/ts/latest/tutorial/&#34;&gt;tutorial&lt;/a&gt; for Angular 2 using Elm and since the original tutorial is pretty long, I&amp;rsquo;ve split it in several posts.&lt;/p&gt;

&lt;h1 id=&#34;angular-2-tutorial-in-elm-part-1&#34;&gt;Angular 2 Tutorial in Elm - Part 1&lt;/h1&gt;

&lt;h3 id=&#34;project-setup&#34;&gt;Project setup.&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;ve written this post and tested the code with version 0.17 of Elm and during this journey I will assume you have only a limited knowledge of the language. Previous exposure to Elm through the Elm tutorial will help to follow it. Anyway I will try to start gently so that even with limited knowledge you can have a global overview of the language.&lt;/p&gt;

&lt;p&gt;This article assumes you have already installed node, npm package manager and Elm on your machine. If it&amp;rsquo;s not the case you can give a look at &lt;a href=&#34;https://nodejs.org/en/&#34;&gt;nodejs&lt;/a&gt; and &lt;a href=&#34;http://elm-lang.org/&#34;&gt;elm-lang&lt;/a&gt; web sites.&lt;/p&gt;

&lt;p&gt;I will focus my comments mainly on Elm code, but the complete source code (including building and deploying scripts) is available on &lt;a href=&#34;https://github.com/tizpuppi/TourOfElm&#34;&gt;github&lt;/a&gt;. For this part of tutorial you can refer to branch &lt;a href=&#34;https://github.com/tizpuppi/TourOfElm/tree/01-HeroEditor&#34;&gt;01-HeroEditor&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;the-hero-editor-screen-only&#34;&gt;The Hero Editor - Screen only&lt;/h3&gt;

&lt;p&gt;In the first part we want to display a simple page with info about an hero. This page will have an input field where the user can change the hero name and automatically reflect this change on the page subtitle. Here is a screenshot of desired behaviour.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tizpuppi.github.io/images/HeroEditor.gif&#34; alt=&#34;Hero Editor Screenshot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start with showing the complete code of an application where there is no interaction with users.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elm&#34;&gt;module Main exposing (..)

import Html exposing (Html, div, h1, h2, label, input, text)
import Html.Attributes exposing (placeholder, value)
import Html.App as App


main : Program Never
main =
    App.beginnerProgram { model = model, view = view, update = update }


type alias AppConfig =
    { title : String }


config : AppConfig
config =
    { title = &amp;quot;Tour of Heroes&amp;quot; }



-- MODEL


type alias Hero =
    { id : Int, name : String }


type alias Model =
    { hero : Hero }


model : Model
model =
    { hero = { id = 1, name = &amp;quot;Windstorm&amp;quot; } }



-- UPDATE


type Msg
    = NoOp


update : Msg -&amp;gt; Model -&amp;gt; Model
update msg model =
    model



-- VIEW


view : Model -&amp;gt; Html Msg
view model =
    div []
        [ h1 [] [ text config.title ]
        , h2 [] [ text (model.hero.name ++ &amp;quot; details!&amp;quot;) ]
        , div []
            [ label [] [ text (&amp;quot;id: &amp;quot; ++ toString model.hero.id) ]
            ]
        , div []
            [ label [] [ text &amp;quot;name: &amp;quot; ]
            , input [ value model.hero.name, placeholder &amp;quot;name&amp;quot; ] []
            ]
        ]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A lot of stuff for a simple screen! But laying down the code following the Elm architecture will help making the code evolve as we will advance adding more features.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s walk throw the code above.&lt;/p&gt;

&lt;p&gt;The first part is the module declaration &lt;code&gt;module Main exposing (..)&lt;/code&gt; where we declare a Main module exposing all top level functions and data types. Every file in Elm is a module and if there is no module declaration by default the compiler assumes that previous declaration is included.&lt;/p&gt;

&lt;p&gt;Then some imports follow. &lt;code&gt;Import&lt;/code&gt; allows us to use some functions declared in other modules. I will not explain here all the details, but if you want to have more info you can have a look at the &lt;a href=&#34;https://guide.elm-lang.org/reuse/modules.html&#34;&gt;Elm official site&lt;/a&gt;. Let&amp;rsquo;s move now to the core of this simple application.&lt;/p&gt;

&lt;h6 id=&#34;model&#34;&gt;model&lt;/h6&gt;

&lt;p&gt;When coding in Elm the first thing I generally start with is the &lt;strong&gt;model&lt;/strong&gt;: this is the heart of the application&amp;rsquo;s logic! So let&amp;rsquo;s have a look at our model.&lt;/p&gt;

&lt;p&gt;In this case we start by creating a type alias &lt;code&gt;type alias Hero = {id: Int, name: String}&lt;/code&gt; to have a nicer name. What is in curly braces is called a record in Elm and it can be thought as a javascript object. Here we specify that an Hero object is made of two fields which in turn are of type Int and String. Those fields are the id and the name of our hero.&lt;/p&gt;

&lt;p&gt;Next let&amp;rsquo;s create an alias for the model itself. At this stage our Model type is simply a record with one Hero object inside &lt;code&gt;type alias Model = { hero : Hero }&lt;/code&gt;. At this point we can create the (initial) model: &lt;code&gt;{ hero = { id = 1, name = &amp;quot;Windstorm&amp;quot; } }&lt;/code&gt;: a single hero with id 1 and name &amp;ldquo;Windstorm&amp;rdquo;. We will pass this to the main application loop, as described later.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;As a side note: even if in the angular tutorial the page title belongs to the model, here I considered refactoring it into an application configuration. This because the title is something the user is not interacting with through all the angular tutorial and I think putting as configuration gives a better view on what it really is (immutable configuration data).&lt;/em&gt;&lt;/p&gt;

&lt;h6 id=&#34;view&#34;&gt;view&lt;/h6&gt;

&lt;p&gt;The second thing we better do is to implement the &lt;strong&gt;view&lt;/strong&gt;. In Elm there is no template language: the html is described in terms of functions being called, which means using the same language as the rest of the code. This has its pros and its cons, but personally, after a first time where I was having some difficulties in reading it, the more I work with it the more I like this approach. I will come back later with some thoughts on this topic. In general the code for the view is pretty straightforward and self-explanatory so I will not spend too much words on the view function.&lt;/p&gt;

&lt;h6 id=&#34;update&#34;&gt;update&lt;/h6&gt;

&lt;p&gt;Finally the code to &lt;strong&gt;update&lt;/strong&gt; the model. In this first part we don&amp;rsquo;t want to include any user interactions, so we define a dummy type Msg: &lt;code&gt;type Msg = NoOp&lt;/code&gt;. The left hand side is the type declaration, and the right hand side is the constructor list. Here we can declare multiple constructor, similar to the union type we find in other languages. Fot this small example we define a single dummy constructor &lt;code&gt;NoOp&lt;/code&gt; meaning that we don&amp;rsquo;t want to perform any update operation. Right now we don&amp;rsquo;t want to implement any user interaction, so the update function takes the current model and returns it.&lt;/p&gt;

&lt;p&gt;All three pieces of this application (model, view, update) are glued together in the App.beginnerProgram function. &lt;code&gt;main = App.beginnerProgram { model = model, view = view, update = update }&lt;/code&gt;This is the main function where the Elm runtime library plays its role: simply said, we can think of it as the responsible for refreshing the view, keeping it in sync with the model, and passing all messages to the update function.&lt;/p&gt;

&lt;h3 id=&#34;the-hero-editor-adding-interactions&#34;&gt;The Hero Editor - Adding interactions&lt;/h3&gt;

&lt;p&gt;Now that everything is in place, we need to add interactions with the users. To do so we have to add an import for HTML events (we only want onInput event for the moment). Html.Events are much like javascript events callback with the difference that what we pass to the event is not a callback function like in javascript, but a message that will be passed to the update function in order to update the model and eventually refresh the view.&lt;/p&gt;

&lt;p&gt;Here you can see the part of the code that we had to change in order to achieve this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elm&#34;&gt;module Main exposing (..)

...
import Html.Events exposing (onInput)
...


-- UPDATE


type Msg
    = Change String


update : Msg -&amp;gt; Model -&amp;gt; Model
update msg model =
    case msg of
        Change newName -&amp;gt;
            let
                oldHero =
                    model.hero

                newHero =
                    { oldHero | name = newName }
            in
                { model | hero = newHero }



-- VIEW


view : Model -&amp;gt; Html Msg
view model =
      ...
        , div []
            [ label [] [ text &amp;quot;name: &amp;quot; ]
            , input [ value model.hero.name, placeholder &amp;quot;name&amp;quot;, onInput Change ] []
            ]
        ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;updating-update&#34;&gt;updating update&lt;/h6&gt;

&lt;p&gt;First we need to update the &lt;code&gt;Msg&lt;/code&gt; type from the dummy &lt;code&gt;NoOp&lt;/code&gt; to &lt;code&gt;Change String&lt;/code&gt;. This means that when there will be an action in the interface, a Msg of type &lt;code&gt;Change String&lt;/code&gt; will be create (for example &lt;code&gt;Change &amp;quot;Superman&amp;quot;&lt;/code&gt;). Then the update function extracts the payload associated with &lt;code&gt;Change Msg&lt;/code&gt; and replaces the model with the new information. First we check that the Msg was build using the Change constructor. This is done using a &lt;code&gt;case&lt;/code&gt; statement (similar to pattern matching in Haskell). Then with the new hero name a new hero record is build, and from there a new model record is created and returned (since it is the last expression).&lt;/p&gt;

&lt;h6 id=&#34;immutable-data&#34;&gt;immutable data&lt;/h6&gt;

&lt;p&gt;Note here a fundamental difference between javascript and Elm language: since all data are immutable by default, we cannot simply change the value of an object (record in this case) but we have to build a new one and evaluate the newly created object. This may seem confusing at the beginning but the combination immutable data + stateless functions allows avoiding buggy side effects making it ultimately easier to refactor code.&lt;/p&gt;

&lt;p&gt;On the view side, we will use the onInput event. This event captures the string value associated with the input field, so that the new value is passed along with Change Msg to the update function.&lt;/p&gt;

&lt;h3 id=&#34;first-take-home-about-elm&#34;&gt;First take home about Elm&lt;/h3&gt;

&lt;p&gt;The first take home about Elm is the lack of template language. This is how Evan Czaplicki (creator of Elm language) explains it in the &lt;a href=&#34;https://groups.google.com/forum/#!topic/elm-discuss/uXjcVyZ5IYo&#34;&gt;Elm discussion group&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;It&amp;rsquo;s nice that the full power of Elm is available with elm-html. No special syntax is needed, it&amp;rsquo;s easy to use lists or dictionaries or functions or whatever else, and you get type checking very easily.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;and also&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;I guess this is controversial, but my feeling is that templating languages tend to evolve into bad languages. What I mean is, there&amp;rsquo;s a pull towards accidental turing-completeness. &amp;ldquo;Wouldn&amp;rsquo;t it be nice to have a for loop?&amp;rdquo; and it gets added. &amp;ldquo;Wouldn&amp;rsquo;t it be nice to have if statements?&amp;rdquo; &amp;ldquo;What about when I want an expression from the host language?&amp;rdquo; {{ normal stuff }} Eventually you have embedded a whole new language in an existing language! And worse, that embedded language is probably fairly haphazard and limited.),&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;For me those words were very illuminating! When it comes to loop or if clauses, the language syntax itself is the best tool to handle those needs. The initial weirdness that we have when coding html using functions is given by the fact that we are so used to associate angular brackets with html that we might feel having more difficulties at parsing with our eyes a piece of Elm code in place of some &lt;em&gt;templated&lt;/em&gt; html. Personally, after some time, I found very clear to read Elm code that describes html views, especially when nicely indented using the Elm syntax guide&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Since we touched the loop subject, let&amp;rsquo;s move to the next post to see how functional language deal with it without using any &lt;code&gt;for ...&lt;/code&gt; loop syntax&amp;hellip;&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;See &lt;a href=&#34;https://github.com/avh4/elm-format&#34;&gt;elm-format&lt;/a&gt; from example. This is a very nice tool that formats Elm source code according to a standard set of rules. Styling wars among developer working on the same code base will not exist anymore!
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>